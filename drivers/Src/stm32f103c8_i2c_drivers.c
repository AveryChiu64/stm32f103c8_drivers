#include "stm32f103c8_i2c_driver.h"
#include "stm32f103c8_rcc_driver.h"

static void clear_addr_flag(I2CHandler *handler) {
	// Clear ADDR Flag by reading SR1 and SR2
	uint32_t dummy_read = handler->address->SR1;
	dummy_read = handler->address->SR1;
	(void) dummy_read;
}
void i2c_peri_clock_ctrl(I2CRegDef *address, uint8_t en_or_di) {
	if (en_or_di == ENABLE) {
		if (address == I2C1) {
			I2C1_PCLK_EN();
		} else if (address == I2C2) {
			I2C2_PCLK_EN();
		}
	} else {
		if (address == I2C1) {
			I2C1_PCLK_DI();
		} else if (address == I2C2) {
			I2C2_PCLK_DI();
		}
	}
}

void i2c_init(I2CHandler *handler) {

	// Configure Ack
	handler->address->CR1 |= ((handler->settings.ack) << I2C_CR1_ACK);

	// Configure FREQ
	handler->address->CR2 |= (rcc_get_pclk1_value() & 0x3F);

	// Configure device address (we only use 7 bit)
	handler->address->OAR1 |= (handler->settings.device_address << 1);

	// CCR calculations (speed)
	uint16_t ccr_value = 0;
	if (handler->settings.scl_speed <= I2C_SCL_SPEED_SM) {
		// Standard
		ccr_value = rcc_get_pclk1_value() / (2 * handler->settings.scl_speed);
	} else {
		// Fast
		handler->address->CCR |= (1 << I2C_CCR_DUTY);
		handler->address->CCR |= (handler->settings.duty_cycle << I2C_CCR_FS);
		if (handler->settings.duty_cycle == FM_DUTY_2) {
			ccr_value = rcc_get_pclk1_value()
					/ (3 * handler->settings.scl_speed);
		} else {
			ccr_value = rcc_get_pclk1_value()
					/ (25 * handler->settings.scl_speed);
		}
	}
	handler->address->CCR |= ccr_value & 0xFFF;

	//TRISE configuration
	if (handler->settings.scl_speed <= I2C_SCL_SPEED_SM) {
		handler->address->TRISE = (rcc_get_pclk1_value() / 1000 + 1) & 0x3F;
	} else {
		handler->address->TRISE = (rcc_get_pclk1_value() * (300 / 1000) + 1)
				& 0x3F;
	}
}

void i2c_master_tx(I2CHandler *handler, uint8_t *tx_buffer, uint32_t len,
		uint8_t slave_address) {
	// Generate start condition
	handler->address->CR1 |= (1 << I2C_CR1_START);

	// Confirm start condition has been generated by checking SB flag
	// SCL will be stretched until SB is cleared
	while (!i2c_get_flag_status(handler->address, I2C_SB_FLAG))
		;

	// Send address of slave with r/w bit set to write (0)
	slave_address = slave_address << 1;
	slave_address &= ~(1); // Slave address + r/w bit
	handler->address->DR = slave_address;

	// Check ADDR Flag (ACK)
	while (!i2c_get_flag_status(handler->address, I2C_ADDR_FLAG))
		;

	clear_addr_flag(handler);

	// Send data until length becomes 0
	while (len > 0) {
		while (!i2c_get_flag_status(handler->address, I2C_TXE_FLAG))
			;
		handler->address->DR = *tx_buffer;
		tx_buffer++;
		len--;
	}

	// Wait for TXE = 1 and BTF = 1 before generating stop condition
	while (!i2c_get_flag_status(handler->address, I2C_TXE_FLAG))
		;
	while (!i2c_get_flag_status(handler->address, I2C_BTF_FLAG))
		;

	// Generate stop condition
	handler->address->CR1 |= (1 << I2C_CR1_STOP);
}

void i2c_master_rx(I2CHandler *handler, uint8_t *rx_buffer, uint32_t len,
		uint8_t slave_address) {
	// Generate start condition
	handler->address->CR1 |= (1 << I2C_CR1_START);

	// Confirm start condition has been generated by checking SB flag
	// SCL will be stretched until SB is cleared
	while (!i2c_get_flag_status(handler->address, I2C_SB_FLAG))
		;

	// Send address of slave with r/w bit set to read (1)
	slave_address = slave_address << 1;
	slave_address |= 1 << 0; // Slave address + r/w bit
	handler->address->DR = slave_address;

	// Check ADDR Flag (ACK)
	while (!i2c_get_flag_status(handler->address, I2C_ADDR_FLAG))
		;

	// Read data
	if (len == 1) {
		// Disable acking
		handler->address->CR1 &= ~(1 << I2C_CR1_ACK);

		// Generate stop condition
		handler->address->CR1 |= (1 << I2C_CR1_STOP);

		clear_addr_flag(handler);

		// Wait until RXNE becomes 1
		while (!i2c_get_flag_status(handler->address, I2C_RXNE_FLAG))
			;

		// Read the data
		*rx_buffer = handler->address->DR;

	} else if (len > 1) {
		clear_addr_flag(handler);
		for (int i = len; i > 0; i--) {
			while (!i2c_get_flag_status(handler->address, I2C_RXNE_FLAG))
				;
			if (i == 2) {
				// Stop
				handler->address->CR1 &= ~(1 << I2C_CR1_ACK);
				handler->address->CR1 |= (1 << I2C_CR1_STOP);
			}
			// Read the data
			*rx_buffer = handler->address->DR;
			rx_buffer++;
		}

	}
	// Re-enable ACKing
	if (handler->settings.ack == ACK_ENABLE) {
		handler->address->CR1 |= (1 << I2C_CR1_ACK);
	}
}

void i2c_peripheral_control(I2CRegDef *address, uint8_t en_or_di);
uint8_t i2c_get_flag_status(I2CRegDef *address, uint32_t flag_name) {
	if (address->SR1 & flag_name) {
		return FLAG_SET;
	}
	return FLAG_RESET;
}

void i2c_irq_interrupt_config(uint8_t irq_number, uint8_t en_or_di) {
	uint8_t index = irq_number / 32;
	uint8_t section = irq_number % 32;
	if (en_or_di == ENABLE) {
		*(NVIC_ISER_BASEADDR + index * 4) |= (1 << section);
	} else {
		*(NVIC_ICER_BASEADDR + index * 4) |= (1 << section);
	}
}

void i2c_irq_priority_config(uint8_t irq_number, NvicIrqPriority irq_priority) {
	uint8_t index = irq_number / 4;
	uint8_t iprx_section = irq_number % 4;
	uint8_t shift = ((8 * iprx_section) + (8 - NO_PR_BITS_IMPLEMENTED));
	*(NVIC_IPR_BASEADDR + (index * 4)) |= (irq_priority << shift);

}

__weak void i2c_application_event_callback(I2CHandler *handler,
		uint8_t application_event) {

}
